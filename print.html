<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>lol Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview-architecture.html"><strong aria-hidden="true">1.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="log-snapshot.html"><strong aria-hidden="true">1.1.</strong> Log and Snapshot</a></li><li class="chapter-item expanded "><a href="snapshot-tag.html"><strong aria-hidden="true">1.2.</strong> Snapshot Resource and Tag</a></li><li class="chapter-item expanded "><a href="storage-abstraction.html"><strong aria-hidden="true">1.3.</strong> Storage Abstraction</a></li><li class="chapter-item expanded "><a href="snapshot-types.html"><strong aria-hidden="true">1.4.</strong> Snapshot Types (Copy and Fold)</a></li></ol></li><li class="chapter-item expanded "><a href="client-interactions.html"><strong aria-hidden="true">2.</strong> Client Interactions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query-processing.html"><strong aria-hidden="true">2.1.</strong> Optimized Query Processing</a></li><li class="chapter-item expanded "><a href="gateway.html"><strong aria-hidden="true">2.2.</strong> Gateway</a></li></ol></li><li class="chapter-item expanded "><a href="cluster-management.html"><strong aria-hidden="true">3.</strong> Cluster Management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="membership-change.html"><strong aria-hidden="true">3.1.</strong> Single-server changes</a></li></ol></li><li class="chapter-item expanded "><a href="election.html"><strong aria-hidden="true">4.</strong> Leader Election</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="failure-detection.html"><strong aria-hidden="true">4.1.</strong> Leader Failure Detection</a></li><li class="chapter-item expanded "><a href="timeout-now.html"><strong aria-hidden="true">4.2.</strong> Leadership Transfer Extension</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">5.</strong> Tools</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">6.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">lol Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview-of-the-architecture" id="overview-of-the-architecture">Overview of the architecture</a></h1>
<p>This chapter describes the overview of the architecture.</p>
<p><img src="images/overview.png" alt="" /></p>
<p><code>RaftCore</code> is the heart of the Raft system. It includes internal states and functions that typically happens side effects.</p>
<p>Around the <code>RaftCore</code>, there are many companion threads that loops and calls functions to <code>RaftCore</code> when some conditions are met. Some threads don't simply loop but wait for some conditions to immediately wake up when it is met. It may be a bit surprise that even gRPC server is a thread that interacts with the <code>RaftCore</code>. How much threads are there? As of 0.4, there are more than 10 threads around the core. This architecure is much like operating system that daemon threads are orbiting around the kernel.</p>
<p>The last element of the system is <code>RaftApp</code>. 
As its name suggests, it is a user application runs on the <code>RaftCore</code>. The responsibility of the <code>RaftApp</code> is said to be only two things:</p>
<ol>
<li>Apply the messages to the state machine</li>
<li>Make a new snapshot</li>
</ol>
<p>Combining these three things together, you can build your own Raft process that interacts with other Raft processes to form a Raft cluster of your own.</p>
<p>If you are ready to implement your own <code>RaftApp</code>, API doc and the KVS implementation under kvs/ would help.</p>
<h1><a class="header" href="#log-and-snapshot" id="log-and-snapshot">Log and Snapshot</a></h1>
<p>To explain how I've designed the log and the snapshot in this library,
tracing the evolution of the design would be the quickest way.</p>
<h2><a class="header" href="#v1-snapshot-as-a-log-entry" id="v1-snapshot-as-a-log-entry">v1: Snapshot as a log entry</a></h2>
<p>lol has started as a company project and it's aim is to 
replicate data in the same order in the cluster then we considered Raft would fit.
That was my journey began.
The name &quot;lol&quot; comes from our project. (one of the two l means log but the another is secret)
It is not a joke.</p>
<p>Since our aim is to replicate the log, the log centric design is natural to start with.
Also, I don't like to implement InstallSnapshot RPC as described in Raft dissertation
because it would certainly introduce extra complexity to the software.</p>
<p>That way, the design v1 is drawn.</p>
<p><img src="images/log-v1.png" alt="" /></p>
<p>In this design, everything is log entry. Everything includes not only the 
user command but snapshot and special entries to change the membership.
Log entry has a pair of term and index to previous entry so to ensure the log consistency,
and the payload in sequence of byte for versatility.
Since everything is log entry, everything in done under Raft's log replication mechanism.
This is so simple and easy to implement. But in terms of versatility, this design choice is not the optimimal.</p>
<p>Why is it not optimal? The main reason is the snapshot's size is limited by the
system memory since we must read or write the entry after putting it in buffer. (Consider Put method in RocksDB) We could avoid this by some implementation hacks like streaming the snapshot part only but this would destroy the interfaces and, not beatiful at all. Then we have to find a new design.</p>
<h2><a class="header" href="#v2-snapshot-inventory" id="v2-snapshot-inventory">v2: Snapshot Inventory</a></h2>
<p>The problem must root in the fact that we try to deal with completely different things, snapshot and normal entries, in the same way. That made me come up with the idea of <em>snapshot inventory</em>.</p>
<p>In Raft dissertation, InstallSnapshot RPC is PUSH operation because it is initiated in leader node and the snapshot chunks are sent in streaming to followers.</p>
<p>My idea is <em>completely the opposite</em>: <code>GetSnapshot</code> RPC is initiated by follower and leader returns the snapshot in streaming after finding it in the snapshot inventory. This is a PULL operation.</p>
<p><img src="images/log-v2.png" alt="" /></p>
<p>In design v2, application snapshot is expelled from the snapshot entry and then put in snapshot inventory. The snapshot entry still exists and replicated to slow followers in the same way as in v1. The difference is: when follower received snapshot entry, it calls <code>GetSnapshot</code> RPC to the sender (in this case it must be a leader) to request the application snapshot in stream. When the <code>GetSnapshot</code> RPC is completed and the snapshot is stored in the snapshot inventory of its own, the follower node commits the snapshot entry just like the way filesystem firstly store the file data and lastly metadata to complete the operation.</p>
<p>The great point of this algorithm is that leader node doesn't have to find slow nodes but slow node is noticed in the way of log replication. This makes the implemetation pretty simple and thus bug-free.</p>
<h1><a class="header" href="#snapshot-resource-and-tag" id="snapshot-resource-and-tag">Snapshot Resource and Tag</a></h1>
<p>In the previous section, you have learned that the snapshot is placed in somewhere outside the log entry and copy to other nodes in streaming.</p>
<p>The snapshot entity that is made from the stream and sent in stream is called <em>snapshot resource</em>.</p>
<p>lol does't care what it actually is and where it is actually placed but let's call it <em>snapshot inventory</em>.</p>
<p>Another player is called <em>snapshot tag</em>.
Snapshot tag is like metadata that identifies a snapshot resource.</p>
<p><img src="images/snapshot-tag.png" alt="" /></p>
<p>In <code>RaftApp</code>'s <code>apply_message</code>, you can return a new snapshot tag from the function after creating the corresponding snapshot resource and saving it.</p>
<p>The snapshot tag is then saved in <code>RaftStorage</code> so it can be used later and its snapshot resource can be purged when it is older than the latest snapshot.</p>
<p>For example, snapshot tag can be a file path when snapshot resource is a file and snapshot tag can be a object key when the snapshot resource is placed in Amazon S3.</p>
<h1><a class="header" href="#storage-abstraction" id="storage-abstraction">Storage Abstraction</a></h1>
<p><code>RaftStorage</code> is the abstraction of backing storage.
Conceptually, it includes the recent vote, log and snapshot tags. Every snapshot entry has a corresponding snapshot tag that points to actual snapshot resource.</p>
<p>By default, lol provides two implementations: one is in-memory type using BTreeMap and the another is persistent type using RocksDB. In most cases, you don't need to implement your own but choose from these two.</p>
<p>Some other Raft libraries like async-raft defines one thick abstraction that kind of mixes RaftApp and RaftStorage but I went the different way because these two can be cleanly separated in my architecture and it is more user-friendly as all user needs to implement is <code>RaftApp</code>: no need to re-implemented the RocksDB backed storage which is not a piece of cake actually.</p>
<h1><a class="header" href="#snapshot-types-copy-and-fold" id="snapshot-types-copy-and-fold">Snapshot Types (Copy and Fold)</a></h1>
<p>The most difficult part of Raft implementation is how to deal with the snapshot. If you are a Raft implementator you must agree.</p>
<p>From the word &quot;snapshot&quot; you may imagine it is a copy (or light-weight snapshot) of the state machine which is returned from <code>RaftApp</code>. Yes, lol calls this type of snapshotting <em>Copy snapshot</em>. When <code>RaftApp</code> returns a Copy snapshot from <code>apply_message</code> this snapshot is granted as a snapshot up to the current <code>apply_index</code>.</p>
<p>From different aspect, snapshot can be seen as recomputing the log entries up to some point in time. lol call this type of snapshot <em>Fold snapshot</em>.</p>
<p>lol supports both snapshots: Copy and Fold.</p>
<p>The comparison between these two is copy cost + overhead VS recomputation cost: Copy snapshot need to copy the current snapshot in <code>apply_message</code> so copy cost happens (even RocksDB or <a href="https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt">dm-thin</a>'s snapshot is not zero-cost) and the operation takes longer. Fold snapshot on the other hands, can be executed in parallel with <code>apply_message</code> but cost a lot from recomputation.</p>
<h1><a class="header" href="#client-interactions" id="client-interactions">Client Interactions</a></h1>
<p>In Raft, command is sent to the leader and the command is processed by the state machine. That is the textbook description.</p>
<p>However, this needs to send the request to the leader (lol implements forwarding so user request sent to any of the servers are forwarded to the leader), the command is replicated to the majority of servers, wait for application to state machine and finally acks. This takes much time.</p>
<p>Some command may need all these processes before ack but other may not. For example, some command may be allowed to ack before log application as it is guaranteed to be applied in some time later.</p>
<p>lol allows clients to interact with the cluster or particular node in a variety of ways. Here is the list:</p>
<ul>
<li><strong>RequestApply</strong>: The command is sent to the leader, appended to log, replicated to majority, applied and then ack.</li>
<li><strong>RequestCommit</strong>: The command is sent to the leader, appended to log, replicated to majority and then ack.</li>
<li><strong>RequestProcess</strong>: The command is sent to the leader, processed and then ack.</li>
<li><strong>RequestProcessLocally</strong>: The command is sent to the designated server, processed and then ack.</li>
</ul>
<h1><a class="header" href="#optimized-query-processing" id="optimized-query-processing">Optimized Query Processing</a></h1>
<p>In bare Raft, any application commands are appended to log and brought to the state machine to apply. However, if the command is query which doesn't have any side-effects, optimization is possible.</p>
<p>In <code>RequestApply</code>, if the request's <code>mutation</code> is false then the request is recognized as query. As described in $6.4 of Raft dissertation, the query waits for the <code>read_index</code> (the <code>commit_index</code> at the moment the query hit the server) to be applied and processed soon after that.</p>
<p>In implementation, queries are firstly put into <code>QueryQueue</code> and processed laster in parallel if there are more than one queries waiting for the same <code>read_index</code> to complete.</p>
<h1><a class="header" href="#gateway" id="gateway">Gateway</a></h1>
<p>In Raft, client request is sent to the leader and processed by the leader. So how did the client know who is the leader?</p>
<p>In Raft dissertation, some algorithm are described. One of which is sending back knowing leader as a hint when client sent the request to some non-leader. Forwarding the request to leader is also explained.</p>
<p>But how do you access the follower? More precisely, how do you know at least one node in the current membership?</p>
<p>lol's <code>Gateway</code> tracks the current membership by polling the membership so client can grab at least one node in the cluster. After giving some valid members to the <code>Gateway</code> manually, <code>Gateway</code> automatically tracks the cluster until it is destructed.</p>
<p><img src="images/gateway.png" alt="" /></p>
<h1><a class="header" href="#cluster-management" id="cluster-management">Cluster Management</a></h1>
<p>In lol adding and removing a server to and from the cluster is just an extension of normal log replication. This means the cluster must have a leader to accept spacial requests: <code>AddServer</code> and <code>RemoveServer</code> which leads to append a special command called <code>ClusterConfiguration</code>.</p>
<p>When you start a single Raft server, you may think the node automatically form a small cluster with one node and become a leader but this is a wrong assumption because starting a second server will cause <em>split brain</em> where there are two leaders at the same time. This is what Raft's election algorithm tries to avoid by choosing only one leader in a single term.</p>
<p>You now learned that starting a server does not automatically form a cluster nor give it a leadership. However, this leads to an other problem: How to add servers? Since there is no leader to accept <code>AddServer</code> request.</p>
<p>When a server received <code>AddServer</code> request and it doesn't belong to any cluster, it forms a cluster with only itself, regardless of the leadership.</p>
<p><img src="images/cluster-management.png" alt="" /></p>
<h1><a class="header" href="#single-server-changes" id="single-server-changes">Single-server changes</a></h1>
<p>There are two ways to change the cluster membership in Raft: one is by joint concensus algorithm and the another is single-server changes.</p>
<p>In the initial Raft dissertation in journal, joint consensus algorithm was used to change the membership but later the author found the fault in joint consensus algorithm, and the lastest dissertation uses single-server changes. lol uses this.</p>
<p>So what is single-server changes? In accordance with the name, this algorithm add or remove only one server at a time.</p>
<p>These operations are represented as special requests (<code>AddServer</code> and <code>RemoveServer</code>) and it turns into <code>ClusterConfiguration</code> command in the log which is then replicated to the cluster as well as normal commands.</p>
<p>The rational behind this is a single-server change always overlap at least one node between before and after. The following figure from Raft dissertation describes a case of adding one node.</p>
<p><img src="images/single-server-changes.png" alt="" /></p>
<p>So the next leader always know the lastest membership and the consensus on membership change never be lost.</p>
<h1><a class="header" href="#leader-election" id="leader-election">Leader Election</a></h1>
<p>In Raft, leader has a spectial authority in the cluster.</p>
<p>The algorithm proves only one leader exists in one term and the leader is at least
&quot;stronger&quot; (I have no idea on better expression) than the majority of the cluster servers.
The principle is very simple however, there are non-trivial corner cases and some useful extensions.</p>
<h1><a class="header" href="#leader-failure-detection" id="leader-failure-detection">Leader failure detection</a></h1>
<p>Typical Raft implementation uses static election timeout to detect leader failure however, this strongly assumes that latency between nodes is uniform and measurable in prior. The assumption is broken when you go out to cloud.</p>
<p>To solve this, lol uses <strong>adaptive failure detection</strong> algorithm called Phi-Accurual detection algorithm. The concept is very simple: the history of heartbeats is given and assume they are distributed normally then we are able to calculate the possiblity of getting another heartbeat in the future.</p>
<p>With this feature, applications based on lol can be deployed in cloud where the latency between nodes may be difference and unstable.</p>
<h1><a class="header" href="#leadership-transfer-extension" id="leadership-transfer-extension">Leadership Transfer Extension</a></h1>
<p>In Raft, leader is chosen by election.
Election happens when follower considers leader is dead.</p>
<p>If leader is removed from the cluster, every client requests
fails before a new leader is elected.</p>
<p>To avoid this, lol implements <code>TimeoutNow</code> RPC which asks some node to
immediately start election (by becoming candidate in new term) regardless of election timeout.</p>
<p>In lol, when leader is removed from the cluster, this <code>TimeoutNow</code> RPC is sent to 
one of the living nodes so a new leader is immediately chosen.</p>
<p>This RPC is also used to pin leader node by sending it from outside the cluster.
In some senario, some node is more suitable for being a leader than other nodes.
Leader pinning is used in such case.</p>
<h1><a class="header" href="#tools" id="tools">Tools</a></h1>
<ul>
<li><a href="https://github.com/akiradeveloper/lol/tree/master/lol-admin">lol-admin</a>: Command line tool for admin</li>
<li><a href="https://github.com/akiradeveloper/lol/tree/master/lol-monitor">lol-monitor</a>: TUI application to monitor the cluster</li>
</ul>
<h1><a class="header" href="#references" id="references">References</a></h1>
<ul>
<li><a href="https://github.com/ongardie/dissertation">Raft Dissertation</a>: Diego Ongaro's Dissertation in Stanford Univ.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
